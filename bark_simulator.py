import csv
import random
from datetime import datetime, timedelta

# Configuration
# Set number of days to generate, the starting date, and the output file
# Note that unlike the main program, this will overwrite the file, not append to it

NUM_DAYS = 365
START_DATE = datetime(2025, 1, 1)
OUTPUT_FILE = "bark_log_dummy.csv"

# Randomization factor functions
# Factors into bark event generation; the higher the random factor, the more barks occur

# Randomly determine if a day is good, bad, or normal.
def get_day_factor():
    r = random.random()
    if r < 0.2:
        return 0.5   # good day
    elif r > 0.8:
        return 1.8   # bad day
    return 1.0       # normal day

# Return a higher value for warmer months, assuming dogs are outside more
def get_season_factor(month):
    if month in [12, 1, 2]:   # winter
        return 0.7
    elif month in [6, 7, 8]:  # summer
        return 1.3
    return 1.0

# Return a value based on time of day, assuming dogs are more active during the day
def get_hour_factor(hour):
    if hour in range(0, 5): # night
        return 0.5
    return 1.0

# Return a higher value on weekends, assuming dogs are less active while owners are at work
def get_weekday_factor(weekday):
    if weekday in [5, 6]:
        return 1.3
    return 1.0


# Simulation
# Randomly generate barking events using factors generated by the above functions

rows = []

current_day = START_DATE

for _ in range(NUM_DAYS):

    # Begin each day at midnight
    day_start = current_day.replace(hour=0, minute=0, second=0)
    day_end = day_start + timedelta(days=1)

    day_factor = get_day_factor()
    season_factor = get_season_factor(current_day.month)

    event_time = day_start

    while event_time < day_end:
        hour_factor = get_hour_factor(event_time.hour)
        weekday_factor = get_weekday_factor(event_time.weekday())

        # Combined factor influences how frequent barking is
        activity_factor = day_factor * season_factor * hour_factor * weekday_factor

        # Bark duration
        duration = round(random.uniform(3, 45), 2)

        rows.append([
            event_time.strftime("%Y-%m-%d %H:%M:%S"),
            "barking",
            duration
        ])

        # Gap until next bark (scaled by activity)
        base_gap = random.randint(20, 900)
        gap_seconds = base_gap / activity_factor

        event_time += timedelta(seconds=duration + gap_seconds)

    current_day += timedelta(days=1)

# -----------------------
# WRITE CSV
# -----------------------

with open(OUTPUT_FILE, "w", newline="") as f:
    writer = csv.writer(f)
    writer.writerow(["timestamp", "event", "duration"])
    writer.writerows(rows)

print(f"Generated {len(rows)} bark events across {NUM_DAYS} days.")
print(f"Saved to {OUTPUT_FILE}")
